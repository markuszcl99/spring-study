# 《Spring 5.x源码解析之Spring AOP API整体的设计与实现》

> 学好路更宽，钱多少加班。---- mercyblitz

## 一、前言

> 大家好，欢迎阅读《Spring 5.x源码解析》系列，本篇作为该系列的第一篇，先入手AOP源码解析，后补齐IoC源码内容。文章内容基于[小马哥讲 Spring AOP 编程思想](https://time.geekbang.org/course/intro/100066301?tab=catalog)以及[Spring源码深度解析（第2版）](https://book.douban.com/subject/30452948/)。笔者多次阅读上述学习资料，形成个人关于Spring的知识总结，希望能帮助各位小伙伴！

## 二、本文概览

![Spring AOP API 整体设计与实现](../../../../../../../../../../../Desktop/图片/博客图片/Spring AOP API设计与实现文章/Spring AOP API 整体设计与实现.png)

## 三、核心API介绍

### 1、JoinPoint(连接点)

> 在Spring AOP中，有关连接点实现的API有以下几种：

![JoinPoint](../../../../../../../../../../../Desktop/图片/博客图片/Spring AOP API设计与实现文章/JoinPoint.png)

对上述API，我们下面做下详细介绍：

- JoinPoint-最顶层接口，在AOP术语中表示：程序运行时的连接点。运行时连接点是发生在静态连接点(程序真正发生调用的地方)上的事件。它包含以下几种方法：
  - Object proceed() : 进行链中下一个拦截器的动作
  - Object getThis() : 返回当前连接点所持有的静态对象实例
  - AccessiblePart getStaticPart() : 返回当前连接点所在的静态代码块
- Invocation-继承JoinPoint，并提供获取目标方法参数的功能，也可以进行修改以变更目标方法的行为
  - Object[] getArguments() : 将参数作为数组对象进行获取，并且可以对参数进行修改来该表目标方法的行为
- MethodInvocation-继承Invocation，是对方法调用的描述，在方法被调用的时候提供给拦截器
  - Method getMethod() : 返回被调用的方法对象
- ConstructorInvocation-继承Invocation，对构造器调用的描述，Spring AOP仅支持对方法调用的拦截，所以该接口在Spring内部并没有被实现
- ProxyMethodInvocation-继承MethodInvocation，允许目标方法访问代理对象
  - Object getProxy() : 返回代理对象
  - MethodInvocation invocableClone() : 创建此对象的克隆，在拦截器调用mi.proceed()之前进行克隆，则拦截器可执行多次mi.proceed()
  - MethodInvocation invocableClone(Object... arguments) : 创建此对象的克隆，对上面方法的重载，支持修改方法的参数
  - void setArguments(Object... arguments) : 修改方法的参数，执行该动作之后，后续的拦截器执行链都会使用新参数进行目标连接点的调用
  - void setUserAttribute(String key,@Nullable Object value) : 对用户属性添加到此Invocation，方便后续执行链中获取到该值，AOP框架不使用该方法，该方法提供给用户使用
  - Object getUserAttribute(String key) : 获取指定Key的用户属性
- ReflectiveMethodInvocation-继承ProxyMethodInvocation，Spring AOP对MethodInvocation的具体实现，基于JDK反射实现连接点的执行
- CglibMethodInvocation-继承ReflectiveMethodInvocation，Spring AOP对MethodInvocation的另一种具体实现，基于Cglib字节码提升实现连接点的执行，重写了父类的invokeJoinPoint()方法，改变了其行为

### 2、Pointcut(切入点)

> 在Spring AOP中，有关Pointcut实现的API有以下几种：

![Pointcut](../../../../../../../../../../../Desktop/图片/博客图片/Spring AOP API设计与实现文章/Pointcut.png)

关于Pointcut接口的实现有很多，上述是使用较多的实现。对于各个API的详细介绍如下：

- Pointcut-最顶层接口，定义了切入点的核心组件(ClassFilter以及MethodMatcher)，并提供默认Pointcut实现-TruePointcut，即所有方法都匹配
- ClassFilter-切入点核心组件之一，在切入点匹配时进行类筛选的功能
  - boolean matchs(Class<?> clazz) : 实现对目标类的过滤
  - 默认实现-TrueClassFilter，默认所有类均符合条件
- MethodMatcher-切入点核心组件之一，在切入点匹配是进行目标方法过滤的功能，提供静态与动态时对方法进行评估两种功能
  - boolean matches(Method method, Class<?> targetClass) : 静态匹配
  - boolean isRuntime() : 是否进行运行时匹配
  - boolean matches(Method method, Class<?> targetClass, Object... args) : 运行时匹配
  - 默认实现-TrueMethodMatcher，默认匹配所有方法
- StaticMethodMatcherPointcut-便利实现，继承MethodMatcher，实现Pointcut。提供方法静态匹配，不支持运行时匹配
  - 该类为抽象接口，子类继承后实现boolean matches(Method method, Class<?> targetClass)静态匹配方法即可
  - JdkRegexpMethodPoint即是继承StaticMethodMatcherPointcut，扩展了正则表达式匹配的实现
- ContolFlowPointcut-控制流实现，提供异常栈的方法匹配，是一个方法链是式的匹配，如果目标方法被其中某一个StackTraceElement匹配则返回true，否则返回false。这个实现有点影响性能，一般不使用
- ComposablePointcut-组合实现，提供union、intersection功能实现多个Pointcut进行组合匹配的功能
- ExpressionPointcut-通过字符串表达式实现切入点
  - String getExpression() : 返回该切入点的字符串表达式
- AbstractExpressionPointcut-实现ExpressionPointcut，提供location以及expression字符串属性的功能
- AspectJExpressionPointcut-继承AbstractExpressionPointcut，实现通过AspectJ weaver计算切入点表达式
  - 支持十种原语实现，就不粘贴在这里，详情可去看源码org.springframework.aop.aspectj.AspectJExpressionPointcut#SUPPORTED_PRIMITIVES
  - obtainPointcutExpression() : 构建AspectJ表达式，AspectJExpressionPointcut的核心方法
  - boolean matches(Method method, Class<?> targetClass) : 静态匹配，通过AspectJ weaver计算出JoinPointMatch，调用其matches方法返回最终是否匹配
  - boolean isRuntime() : 是否进行运行时匹配，obtainPointcutExpression().mayNeedDynamicTest()
  - boolean matches(Method method, Class<?> targetClass, Object... args) : 运行时匹配，通过AspectJ weaver计算出JoinPointMatch，调用其matches方法返回最终是否匹配

### 3、Advice(执行动作)

> 在Spring AOP中，有关Advice实现的API如下所示：

![Advice](../../../../../../../../../../../Desktop/图片/博客图片/Spring AOP API设计与实现文章/Advice.png)

关于Advice接口，可以分为前置、后置(最终、异常、返回)、环绕三种拦截动作来看，下面我们详细介绍下相应的API接口：

- Advice-顶层接口，是一个标记接口，无任何动作
- BeforeAdvice-继承Advice，是一个标记接口
- MethodBeforeAdvice-继承BeforeAdvice，提供方法前置拦截功能
  - void before(Method method, Object[] args, @Nullable Object target) : 方法前置调用接口
- AfterAdvice-继承Advice，是一个标记接口
- AfterReturningAdvice-继承AfterAdvice，提供方法成功返回后的回调功能
  - void afterReturning(@Nullable Object returnValue,Method method,Object[] args,@Nullable Object target) : 回调接口
- ThrowsAdvice-继承AfterAdvice，是一个标记接口，似乎没有类实现它，在ThrowsAdviceInterceptor中的throwsAdvice字段被声明为Object类型
- Interceptor-继承Advice，也是一个标记接口
- MethodInterceptor-继承Interceptor，顾名思义，方法拦截器，在方法调用途中对目标方法进行拦截。也是AOP框架中拦截器链对象的统一接口
  - MethodBeforeAdviceInterceptor : 前置拦截器，具体实现原理是在目标方法被调用前，先执行MethodBeforeAdvice#before(xxx)实现前置拦截
  - AfterReturningAdviceIntercetpor : 后置返回拦截器，具体实现原理是在目标方法被成功调用后，继续执行AfterReturningAdvice#afterReturning(xxx)实现方法返回拦截
  - ThrowsAdviceInterceptor : 后置异常返回拦截器，具体实现原理是在捕捉目标方法执行异常，如果符合拦截的异常类型，则通过反射执行对应的拦截方法
  - AspectJAfterAdvice、AspectJAroundAdvice放在AbstractAspectJAdvice中说
- AbstractAspectJAdvice-包装Aspect切面或者Aspect注解通知的一个基类，提供Spring对AspectJ相关方法调用(黑盒)
  - AspectJMethodBeforeAdvice : 前置拦截执行动作实现，基于反射实现before(xxx)方法
  - AspectJAfterReturningAdvice : 后置方法返回执行动作实现，基于反射实现afterReturning(xxx)方法
  - AspectJAfterThrowingAdvice : 后置方法异常拦截执行动作实现，基于反射
  - AspectJAfterAdvice : 后置最终拦截执行动作实现，基于反射
  - AspectJAroundAdvice : 环绕拦截执行动作实现，基于反射
  - 上述各类执行动作最终都是调用AbstractAspectJAdvice基类提供的invokeAdviceMethod(@Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex)方法，实现各Advice执行动作

### 4、Advisor

> 在Spring AOP中，有关Advisor的API如下图所示：

![Advisor](../../../../../../../../../../../Desktop/图片/博客图片/Spring AOP API设计与实现文章/Advisor.png)

关于Advisor及其子接口，下面进行详细介绍：

- Advisor-最顶层接口，可以提供不同类型的Advice
  - Advice getAdvice() : 获取当前切面的Advice，可以是一个Interceptor、BeforeAdvice、ThrowsAdvice等
  - boolean isPerInstance() : 目前我也不知道它的用处，AOP框架中未使用它，典型的Advisor实现总是返回true
- PointcutAdvisor-继承Advisor，扩展Pointcut与Advice关联的功能
  - Pointcut getPointcut() : 获取关联的切入点
- StaticMethodMatcherPointcutAdvisor-实现PointcutAdvisor，对于静态切入点驱动的Advisor的便捷实现
- InstantiationModelAwarePointcutAdvisor-继承PointcutAdvisor，扩展Advice是否具有懒加载策略，是否意味着延迟初始化
- InstantiationModelAwarePointcutAdvisorImpl-AspectJPointcutAdvisor的内部实现，每个目标方法(Advice方法)都拥有一个该实例 
- AspectPointcutAdvisor-它使AbstractAspectJAdvice适应PointcutAdvisor接口
- AbstractPointcutAdvisor-实现PointcutAdvisor，是一个抽象基类。可以使子类获取指定的Pointcut or Advice或者自由配置相应的Pointcut or Advice
- AbstractBeanFactoryPointcutAdvisor-继承AbstractPointcutAdvisor，与Spring IoC整合，可以指定IoC容器中的Advice Bean，通过BeanName依赖查找来建立关联
- DefaultBeanFactoryPointcutAdvisor-AbstractBeanFactoryPointcutAdvisor具体实现
- AbstractGenricPointcutAdvisor-抽象类，是PointcutAdvisor的通用实现，允许任何Advice被配置
- DefaultPointcutAdvisor-便利实现，允许任何Pointcut与Advice一起使用

- IntroductionAdvisor-继承Advisor，实现Introduction与Advisor关联的功能，这里简单提一下Introduction Advice，它是Spring中特殊的拦截Advice，仅对匹配类，不匹配方法，这也使被代理对象能够被增强
  - ClassFilter getClassFilter() : 获取类匹配器。
  - void validateInterfaces() : 校验接口
  - Class[] getInterfaces() : 获取额外被当前Advisor增强的接口
- DefaultIntroductionAdvisor-IntroductionAdvisor的简单实现
- DeclareParentsAdvisor-与@DeclareParents注解关联，实现AspectJ注解一样的行为。简单说就是声明一个字段被@DeclareParents注解注释，该字段对应实例的方法在目标方法的前or后执行，实现一个类似AspectJ拦截的功能

