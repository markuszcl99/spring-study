# 《Spring 5.x源码解析之Spring AOP 注解驱动使用及其实现原理》

> 学好路更宽，钱多少加班。---- mercyblitz

## 一、前言

> 大家好，欢迎阅读《Spring 5.x源码解析》系列，本篇作为该系列的第二篇，重点介绍Spring AOP在注解驱动编程模式上的使用及其实现原理。文章内容基于[小马哥讲 Spring AOP 编程思想](https://time.geekbang.org/course/intro/100066301?tab=catalog)以及[Spring源码深度解析（第2版）](https://book.douban.com/subject/30452948/)。笔者多次阅读上述学习资料，形成个人关于Spring的知识总结，希望能帮助各位小伙伴！

## 二、本文概览

![Spring AOP 注解驱动使用及其实现原理](../../../../../../../../../../../Desktop/图片/博客图片/未命名文件夹/Spring AOP 注解驱动使用及其实现原理.png)

## 三、使用示例

> 在本节，我们详细介绍Spring AOP所支持的AspectJ注解使用，在目标方法拦截上介绍@Before、@After、@AfterReturning、@AfterThrowing、@Around、@DeclareParents以及在切入点表达式上介绍execution、within、target、this、args、@args、@target、@within、@annotation的使用

### 1、@Aspect

该注解的作用就是定义该类是一个切面，在Spring IoC容器会根据Aspect标记拿出该类，创建对应的Advisor，详细动作会在下节实现原理说。

### 2、AOP通知注解使用

Spring支持AspectJ拦截注解包括@Before、@After、@AfterReturning、@AfterThrowing、@Around，下面简单介绍下他们的作用以及使用方式: 

- @Before: 该注解的作用是定义连接点的前置通知方法，在目标方法调用前执行
- @After: 该注解的作用是定义连接点的最终通知方法，在目标方法执行后执行(目标方法正常或异常情况均会执行)
- @AfterReturning: 该注解的作用是定义连接点的后置返回通知方法，在目标方法成功返回后执行
- @AfterThrowing: 该注解的作用是定义在连接点的后置异常返回通知方法，在目标方法执行异常后执行
- @Around: 环绕通知，可以在目标方法执行前后任意时机执行，目标的方法调用是方法内主动去调用，而上面四个注解是被动调用。

下面看下他们的使用示例:

- 切面以及通知定义

```java
package com.markus.spring.aop.feature.blog.aspect;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;

/**
 * @author: markus
 * @date: 2022/11/29 1:16 PM
 * @Description: 前置方法拦截
 * @Blog: http://markuszhang.com
 * It's my honor to share what I've learned with you!
 */
@Aspect
public class AspectJAnnotationConfig {
    @Before(value = "target(com.markus.aop.overview.EchoService)")
    public void before() {
        System.out.println("这是前置通知");
    }

    @After(value = "target(com.markus.aop.overview.EchoService)")
    public void after() {
        System.out.println("这是方法最终通知");
    }

    @AfterReturning(value = "target(com.markus.aop.overview.EchoService)")
    public void afterReturning() {
        System.out.println("这是方法返回通知");
    }

    @AfterThrowing(value = "target(com.markus.aop.overview.EchoService)")
    public void afterThrowing() {
        System.out.println("这是方法异常通知");
    }

    @Around(value = "target(com.markus.aop.overview.EchoService)")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("这是方法环绕前置通知");
        try {
            Object obj = pjp.proceed();
            System.out.println("这是方法环绕返回通知");
            return obj;
        } catch (Throwable e) {
            System.out.println("这是方法环绕异常通知");
            throw e;
        } finally {
            System.out.println("这是方法环绕最终通知");
        }
    }

}
```

- 使用

```java
package com.markus.spring.aop.feature.blog;

import com.markus.aop.overview.DefaultEchoService;
import com.markus.aop.overview.EchoService;
import com.markus.spring.aop.feature.blog.aspect.AspectJAnnotationConfig;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

/**
 * @author: markus
 * @date: 2022/11/29 1:20 PM
 * @Description: AspectJ注解使用示例
 * @Blog: http://markuszhang.com
 * It's my honor to share what I've learned with you!
 */
@EnableAspectJAutoProxy
public class AspectJAnnotationDemo {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        context.register(AspectJAnnotationDemo.class, AspectJAnnotationConfig.class);
        context.refresh();

        EchoService echoService = context.getBean(EchoService.class);
        echoService.echo("Hello World!");

        context.close();
    }

    @Bean
    public EchoService echoService() {
        return new DefaultEchoService();
    }
}
```

- 控制台结果

```java
// 方法正常执行
这是方法环绕前置通知
这是前置通知
[echo] Hello World!
这是方法环绕返回通知
这是方法环绕最终通知
这是方法最终通知
这是方法返回通知

Process finished with exit code 0
  
// 方法异常执行
这是方法环绕前置通知
这是前置通知
这是方法环绕异常通知
这是方法环绕最终通知
这是方法最终通知
这是方法异常通知
Exception in thread "main" java.lang.RuntimeException: 有一定几率异常
	at com.markus.aop.overview.DefaultEchoService.echo(DefaultEchoService.java:23)
```

### 3、Pointcut切入点表达式

> 在上面我们看到@Before等等注解内都会有一个value = "target(com.markus.aop.overview.EchoService)"，这个value内容是匹配目标方法的表达式，表达式类型有许多并且也可以通过@Pointcut注解来统一处理，@Before等通知注解引用这个Pointcut即可。下面来逐一介绍下表达式的种类以及其使用方法

- 第一种: execution(modifiers-pattern? ret-type-pattern declare-type-pattern.? name-pattern(param-pattern) throws-pattern?)
  - 其中带"?"的表示在表达式中可有可无的
  - modifiers-pattern 表示方法的访问类型
  - ret-type-pattern 表示方法的返回值类型
  - declare-type-pattern 表示方法所在类的类型
  - name-pattern 表示方法签名
  - param-pattern 表示参数的类型
  - throws-pattern 表示异常抛出的类型
- 第二种: within(package),对指定模块下的方法进行匹配
  - package 表示模块，可使用通配符
- 第三种: this(package.class),对指定类下的方法进行匹配
  - package.class 指向代理对象，不可以使用通配符
- 第四种: target(package.class),对指定类下的方法进行匹配
  - package.class 指向目标对象，不可以使用通配符
- 第五种: args(ParameterType,...),对指定参数类型的方法进行匹配
  - ParameterType 表示目标方法的参数类型
- 第六种: @target(package.class),执行方法所在的对象是否被目标注解定义
  - 执行方法的对象，不一定是定义方法的对象，属于运行时匹配，所以@target会将所有原始对象生成代理，所以慎用！
- 第七种: @within(package.class),定义方法所在的对象是否被目标注解匹配
  - 定义方法的对象，属于静态对象
- 第八种: @args(annotationType),目标方法的参数是否被目标注解定义
  - annotationType 注解类型，匹配目标方法的参数是否具备目标注解
- 第九种: @annotation(annotationType),目标方法是否被目标注解定义
  - annotationType 注解类型

上面介绍了各种表达式的定义以及作用，下面来介绍下他们的使用方法：

- 切面以及表达式定义:

```java
 package com.markus.spring.aop.feature.blog.aspect;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

/**
 * @author: markus
 * @date: 2022/12/1 1:27 PM
 * @Description: 横切点表达式使用演示
 * @Blog: http://markuszhang.com
 * It's my honor to share what I've learned with you!
 */
@Aspect
public class AspectJPointcutExpressionConfig {
    // 表示 方法的访问类型为public 任意返回类型 任意类型的specialReferenceDemo方法 参数可有可无
    @Pointcut(value = "execution(public * *.specialReferenceDemo(..))")
    public void executionPointcut() {

    }

    // 表示 匹配在com.markus.spring.aop.feature.blog子模块下的方法
    @Pointcut(value = "within(com.markus.spring.aop.feature.blog.domain.*)")
    public void withinPointcut() {
    }

    // 表示 匹配目标对象是com.markus.spring.aop.feature.blog.domain.DefaultPointcutDemo下的方法
    @Pointcut(value = "target(com.markus.spring.aop.feature.blog.domain.DefaultPointcutDemo)")
    public void targetPointcut() {

    }

    // 表示 匹配代理对象是com.markus.spring.aop.feature.blog.domain.PointcutDemo下的方法
    @Pointcut(value = "this(com.markus.spring.aop.feature.blog.domain.PointcutDemo)")
    public void thisPointcut(){

    }

    // 表示 匹配的方法中参数是ArgsDemo类型
    @Pointcut(value = "args(com.markus.spring.aop.feature.blog.domain.ArgsDemo)")
    public void argsPointcut(){

    }

    // 表示 匹配被@EchoInterface定义的对象下的方法
    // 它是动态匹配的，会为所有目标对象生成代理，所以慎用！例如AOP动态代理通过cglib实现，遇到被final修饰的bean对象，就会抛出异常
    @Pointcut(value = "@target(com.markus.aop.overview.annotation.EchoInterface)")
    public void atTargetPointcut(){

    }

    // 表示 匹配被@EchoInterface定义的对象下的方法
    // 与@target不同，它是属于静态匹配，描述为定义方法的对象被@EchoInterface注释
    @Pointcut(value = "@within(com.markus.aop.overview.annotation.EchoInterface)")
    public void atWithinPointcut(){

    }

    // 表示 匹配参数所属的类型被@EchoInterface注释的所有方法
    @Pointcut(value = "@args(com.markus.aop.overview.annotation.EchoInterface)")
    public void atArgsPointcut(){

    }

    // 表示 匹配被@EchoInterface注释的所有方法
    @Pointcut(value = "@annotation(com.markus.aop.overview.annotation.EchoInterface)")
    public void atAnnotationPointcut(){

    }


    @Before("executionPointcut()")
    public void executionPointcutBefore() {
        System.out.println("this is execution pointcut");
    }

    @Before("withinPointcut()")
    public void withinPointcutBefore() {
        System.out.println("this is within pointcut");
    }

    @Before("targetPointcut()")
    public void targetPointcutBefore(){
        System.out.println("this is target pointcut");
    }

    @Before("thisPointcut()")
    public void thisPointcutBefore(){
        System.out.println("this.is this pointcut");
    }

    @Before("argsPointcut())")
    public void argsPointcutBefore(){
        System.out.println("this is args pointcut");
    }

    @Before("atTargetPointcut()")
    public void atTargetPointcutBefore(){
        System.out.println("this is @target pointcut");
    }

    @Before("atWithinPointcut()")
    public void atWithinPointcutBefore(){
        System.out.println("this is @within pointcut");
    }

    @Before("atArgsPointcut()")
    public void atArgsPointcutBefore(){
        System.out.println("this is @args pointcut");
    }

    @Before("atAnnotationPointcut()")
    public void atAnnotationPointBefore(){
        System.out.println("this is @annotation pointcut");
    }
}
```

- 客户端

```java
package com.markus.spring.aop.feature.blog;

import com.markus.spring.aop.feature.blog.aspect.AspectJPointcutExpressionConfig;
import com.markus.spring.aop.feature.blog.domain.ArgsDemo;
import com.markus.spring.aop.feature.blog.domain.DefaultPointcutDemo;
import com.markus.spring.aop.feature.blog.domain.PointcutDemo;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

/**
 * @author: markus
 * @date: 2022/12/1 10:24 PM
 * @Description: 横切点表达式使用示例
 * @Blog: http://markuszhang.com
 * It's my honor to share what I've learned with you!
 */
@EnableAspectJAutoProxy
public class AspectJPointcutExpressionDemo {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        context.register(AspectJPointcutExpressionDemo.class, AspectJPointcutExpressionConfig.class);
        context.refresh();

        PointcutDemo pointcutDemo = context.getBean(PointcutDemo.class);
        ArgsDemo argsDemo = context.getBean(ArgsDemo.class);
        System.out.println("-----start-----");
        pointcutDemo.specialReferenceDemo(argsDemo);
        System.out.println("-----end-----");
        context.close();
    }

    @Bean
    public PointcutDemo pointcutDemo() {
        return new DefaultPointcutDemo();
    }

    @Bean
    public ArgsDemo argsDemo() {
        return new ArgsDemo("Hello World!");
    }
}
```

- 控制台

```java
-----start-----
this is args pointcut
this is @annotation pointcut
this is @args pointcut
this is @target pointcut
this is @within pointcut
this is execution pointcut
this is target pointcut
this.is this pointcut
this is within pointcut
special reference demo content is 
-----end-----

Process finished with exit code 0
```

## 四、实现原理

## 五、本文总结
